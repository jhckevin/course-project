# course-project
# <a name="整数奇偶归类-排序-排座系统"></a>整数奇偶归类-排序-排座系统

**题干要求：**

QUESTION 7. Classify the elements in an integer array as odd or even 将一个整型数表中的元素按照奇数偶数归类

任务:将所有的奇数移动到偶数前面,并且奇偶数分别按照升序排序。

功能要求:

1)输入一组整数,以顺序结构存储。整数个数不小于20;

2)采用两种以上的算法实现奇、偶数归类。

3)采用两种以上算法实现排序**。**

**需求分析与设计文档**

-----

## <a name="xd979d872ce1f6b3e251ca35cb45f0cc7aba71a0"></a>1 项目背景与情景研究

- **考试排座痛点**\
  监考老师常需按照固定规则（如“奇偶分区”“左右隔开”）快速排定一个合适的不容易作弊的座位，并希望一目了然地查看最终布局。
- **本系统目标**
  1. 读取 ≥ 20 个整数（可视为考生编号）。
  1. 根据奇偶性分类，并分别升序排序。
  1. 将奇数与偶数映射到教室座位（左右或前后排，奇偶方位可选）。
  1. 扩展：支持手动输入、随机生成、CSV 批量导入，处理结果再导出 CSV，自动化并发文件导入后导出；提供算法交互界面以及字符串“伪UI”。
  1. 条件编译后支持算法可视化，以及性能报告

-----

## <a name="x381ae5c91c8c0c9db4f6f047c376131c3fc1467"></a>2 需求概述（功能列表先后顺序）

| 阶段         | 功能                                               | 关键要点                                       |
| :----------- | :------------------------------------------------- | :--------------------------------------------- |
| **输入阶段** | - 手动输入<br>- 随机生成<br>- 多 CSV 文件批量导入  | CSV 行列分隔符可配置，生成随机数，文件读写处理 |
| **归类阶段** | 三种算法任选（稳定额外数组、原地分区、双指针交换） | 时间 O(n)，复杂度优化                          |
| **排序阶段** | 两种算法任选（快速排序、堆排序）                   | 升序，各自独立                                 |
| **排座阶段** | - 左/右排或前/后排<br>- 奇数放左(前)或右(后)       | 行列可设置，情况可设置                         |
| **输出阶段** | - ASCII 座位图<br>- 奇偶各写 CSV                   | 字符串输出算法处理                             |

-----

## <a name="x71edc98ac35fef6b25c5098f63abc9c082d822d"></a>3 数据对象分析

| 对象               | 物理结构               | 说明                          |
| :----------------- | :--------------------- | :---------------------------- |
| raw[]              | int 一维数组           | 原始顺序数据                  |
| odd[]              | 动态数组               | 归类后奇数序列                |
| even[]             | 动态数组               | 归类后偶数序列                |
| Seat seatMap[R][C] | struct Seat 二维顺序表 | R 行 C 列，记录行列索引与编号 |
| CsvFile            | 结构体封装             | 路径、分隔符、行列数          |

-----

## <a name="x6369e8994ea6ad16ea2d64b4976f58318d2aec0"></a>4 数据关系分析

![](Aspose.Words.de905cf6-64ea-43c4-896c-e507e66c1867.001.png)

- **DATASET**：一次处理会话
- **RAW → ODD / EVEN**：奇偶划分
- **ODD / EVEN → SEAT**：根据排布策略映射

-----

## <a name="x6a801cabb8df92f5b94265ddfc2e4038a292905"></a>5 顺序存储方式选择

| 备选     | 访问特点                | 评估                  |
| :------- | :---------------------- | :-------------------- |
| 链表     | 插入 O(1) 但随机访问差  | 不利于排序与随机索引  |
| **数组** | 顺序存储，随机访问 O(1) | ` `排序友好；内存连续 |

综上，采用**一维数组**存整数，二维数组存座位。

-----

## <a name="x225c4087354b9686fb2201e03b785bd12dad3a3"></a>6 功能设计（按执行流排列）

1. **菜单模块**
   - 用户选择数据源、算法、排布方式。
1. **数据采集模块**
   - load\_manual() 
   - load\_random() 
   - load\_csv\_list()
1. **归类模块（Strategy pattern）**
   - classify\_stable()
   - classify\_partition()
   - classify\_two\_ptr()
1. **排序模块（可并行调用）**
   - quick\_sort\_wrapper()
   - heap\_sort()
1. **排座模块**
   - gen\_seat\_map(mode\_lr\_or\_fb, odd\_side)
1. **可视化与导出模块**（可视化可选）
   - render\_ascii() → 终端图
   - write\_csv(odd.csv, even.csv, seat.csv)
1. **性能统计模块**（可选编译）
   - bench\_once(strategyPair, n)

-----

## 7 总体交互控制流程，核心流程，主调度

![](Aspose.Words.de905cf6-64ea-43c4-896c-e507e66c1867.002.png)

核心流程：

![](Aspose.Words.de905cf6-64ea-43c4-896c-e507e66c1867.003.png)

伪代码：主调度：

main():

`    `dataset = load\_data\_choose()

`    `classifier = choose\_classifier()

`    `sorter     = choose\_sort()

`    `split = classifier(dataset.raw, dataset.n)

`    `sorter(split.odd,  split.n\_odd)

`    `sorter(split.even, split.n\_even)

`    `seatMap = gen\_seat\_map(split, cfg)

`    `render\_ascii(seatMap)

`    `export\_csv(split, seatMap)

## 8 交互菜单设计

===== SeatSorter =====

[1] 导入/生成数据

[2] 选择归类算法  (1 稳定 2 原地 3 双指针)

[3] 选择排序算法  (1 快排 2 堆排)

[4] 座位排布设置  (L/R or F/B, 奇数在哪侧)

[5] 排座并显示+导出

[6] 重设数据

[7] 批量文件数据自动化处理    

[q] 退出

1. 步骤可反复调整；只有按 v 才真正执行分类-排序-排座。
1. 导出文件默认 odd.csv, even.csv, seat\_map.csv。
1. 批量文件自动化处理，会批量处理同源文件，将其自定义解析后处理完后写到新的文件中

-----

## <a name="xb4714fbe4c5a24c2e6993969e5218fb220f1c4e"></a>9 算法策略设计

### <a name="xe3c112c9a181c71867eb833ed61e4c0fbee5534"></a>9.1 奇偶归类伪代码与分析

| 名称                          | 核心思想        | 时空复杂度  | 稳定性 |
| :---------------------------- | :-------------- | :---------- | :----- |
| classify\_stable              | 两个缓冲区收集  | O(n) / O(n) | ✅      |
| classify\_partition           | 单指针扫描+交换 | O(n) / O(1) | ❌      |
| classify\_two\_ptr            | 前后双指针对撞  | O(n) / O(1) | ❌      |
| <p></p><p></p><p></p>         |                 |             |        |
| classify\_partition()流程图： |                 |             |        |

![图示

AI 生成的内容可能不正确。](Aspose.Words.de905cf6-64ea-43c4-896c-e507e66c1867.004.png)

伪代码：

classify\_partition(arr, n):

`    `pivot = 0

`    `for i in 0..n-1:

`        `if arr[i] odd:

`            `swap(arr[i], arr[pivot])

`            `pivot++

### <a name="x589556a241a5c40358ff66e274ffbb878e6f577"></a>9.2 排序策略

| 名称     | 思路           | 复杂度          | 额外空间 | 备注   |
| :------- | :------------- | :-------------- | :------- | :----- |
| 快速排序 | 分治，三数取中 | O(n log n) 平均 | O(log n) | 不稳定 |
| 堆排序   | 最大堆下沉     | O(n log n)      | O(1)     | 不稳定 |

快速排序子流程图：![图示

AI 生成的内容可能不正确。](Aspose.Words.de905cf6-64ea-43c4-896c-e507e66c1867.005.png)

-----

## 10 排座输出“伪UI”的范例与规范

这也是字符串算法的一部分，又称ASCII码字符画。

### 10\.1  规范

1. **外框**
   1. 顶部和底部使用 +、- 构成边框，左右两侧使用 |
   1. 四角用 + 表示，水平边线用 -，垂直边线用 |
1. **座位单元**
   1. 固定宽度（如 4～5 字符），格式统一为 [NN]，编号两位数字右对齐
   1. 数量按实际排数×列数决定
1. **过道**
   1. 用 || 或若干空格表示，不计入行列数字
   1. 如果需要多条过道，可按需要增设
1. **朝向标注**
   1. 在图形顶部或底部居中写 Front/Rear，指示当前视图的前后方向
1. **左右侧标注**
   1. 在最底行或最底部横线外注明 Left、Aisle、Right
1. **奇偶分组**
   1. 可根据需求将奇数座号放在左侧或右侧，示例通过交换左右两侧数据实现

### 10\.2  示例

### 示例 1：前排在上，奇数座号在左

+------------------------------------------+

|           考试排座示意（示例 1）         |

+------------------------------------------+

|                  Front                   |

| [01] [03] [05]   ||   [02] [04] [06]     |

| [07] [09] [11]   ||   [08] [10] [12]     |

| [13] [15] [17]   ||   [14] [16] [18]     |

| [19] [21] [23]   ||   [20] [22] [24]     |

|                  Rear                    |

+------------------------------------------+

`                  `Left   Aisle   Right      

- **4 排 6 列**（左右各 3 列）；
- 奇数 [01,03,…] 全部排在左侧，偶数在右侧；
- Front 在顶部，Rear 在底部。

### 示例 2：后排在下，奇数座号在右

+------------------------------------------+

|           考试排座示意（示例 2）         |

+------------------------------------------+

|                  Rear                    |

| [02] [04] [06]   ||   [01] [03] [05]     |

| [08] [10] [12]   ||   [07] [09] [11]     |

| [14] [16] [18]   ||   [13] [15] [17]     |

| [20] [22] [24]   ||   [19] [21] [23]     |

|                  Front                   |

+------------------------------------------+

`                  `Left   Aisle   Right      

- **4 排 6 列**；
- 偶数在左侧，奇数在右侧；
- Front 在底部，Rear 在顶部。

### 10\.3  左右两侧各 2 列，中间无过道，只做前后切换

+------------------------------+

|    考试排座示意（示例 3）    |

+------------------------------+

|             Front            |

| [01] [03] [05] [07] [09] [11]|

| [02] [04] [06] [08] [10] [12]|

|             Rear             |

+------------------------------+

- **2 排 6 列**，无过道；
- 奇数切在第一行，偶数第二行。

以此类推：要切换**前后排**只需上下翻转“Front/Rear”及对应座号分布；要切换**奇数在左/右**，只需左右交换两侧数据段；若需**多通道**或**更多列数/排数**，按以上规范扩展即可。

-----

## <a name="x28e970569e3ab8e0c5da221d4736a2e2634d6c5"></a>11 代码规范化

*/\* seat\_sort.c  —— 唯一源文件 \*/*

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <time.h>

*/\* -------- 常量与类型 -------- \*/*

#define MAX\_N  1024

#define MAX\_R  32

#define MAX\_C  32

*/\* typedef struct …  所有结构体 \*/*

*/\* -------- 工具函数 -------- \*/*

static int is\_odd(int x, int k, int r);

*/\* I/O: load\_manual, load\_random, load\_csv              \*/*

*/\* 归类: classify\_stable, classify\_partition, two\_ptr  \*/*

*/\* 排序: quick\_sort\_wrapper, heap\_sort                 \*/*

*/\* 排座: gen\_seat\_map                                  \*/*

*/\* 输出: render\_ascii, export\_csv                      \*/*

*/\* -------- 菜单与调度 -------- \*/*

static void menu\_loop(void);

*/\* main() 调用 menu\_loop()                              \*/*

-----


## <a name="xb973909835af70e5415be4a58b72f62ea036164"></a><a name="xf85fe13c05bde41bb35d9047fcdd70f54940035"></a>12 性能与正确性验证

- 使用 clock() 记录归类与排序耗时。重点在于与Excel表格自定义宏和函数进行对比，证明算法是有实际意义的，其相的优势明显。可视化处理是否正确仍需确定。
- 批量处理，高度并发能力验证，需要证明这个系统对于多文件导入的状况良好。
- 对不同文件解析处理的健壮性，以及该系统完备性和对用户友好性仍需验证，并适当做出相应改进。

-----

## <a name="xea2c2621f3b38817e0de50dd7d46889e2d1e49b"></a><a name="结论"></a>13可扩展升级与创新（展望）

- 算法创新：针对特定场景：比如排座的针对性垂直领域算法创新。在通用算法基础上进行细化与改进。
- 交互创新：批量设置文件名，颜色宏等功能有效提升交互方式与工作流效率，增加系统可用度
- 并发创新：批量自动化设置作为系统一大特点，可以针对线程（c++）进行优化，提高并发度，并增加系统稳固性，并发健壮性。
- 专用设备优化：经过网络上，权威机构调查，我们可以得知windows市占率较高，可以针对Windows AVX2指令集以及Windows线程接口等进行优化提高并发度与算法在特定机型（较新Windows设备上）的用户体验和重要的效率。

